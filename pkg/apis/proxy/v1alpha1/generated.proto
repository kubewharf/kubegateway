/*
Copyright 2022 ByteDance and its affiliates.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// This file was autogenerated by go-to-protobuf. Do not edit it manually!

syntax = 'proto2';

package github.com.kubewharf.kubegateway.pkg.apis.proxy.v1alpha1;

import "k8s.io/apimachinery/pkg/apis/meta/v1/generated.proto";
import "k8s.io/apimachinery/pkg/runtime/generated.proto";
import "k8s.io/apimachinery/pkg/runtime/schema/generated.proto";

// Package-wide variables from generator "generated".
option go_package = "v1alpha1";

message ClientConfig {
  // Server should be accessed without verifying the TLS certificate. For testing only.
  optional bool insecure = 1;

  // BearerToken is the bearer token for authentication. It can be an service account token.
  optional bytes bearerToken = 2;

  // KeyData contains PEM-encoded data from a client key file for TLS.
  // The serialized form of data is a base64 encoded string
  optional bytes keyData = 3;

  // CertData contains PEM-encoded data from a client cert file for TLS.
  // The serialized form of data is a base64 encoded string
  optional bytes certData = 4;

  // CAData contains PEM-encoded data from a ca file for TLS.
  // The serialized form of data is a base64 encoded string
  optional bytes caData = 5;

  // QPS indicates the maximum QPS to the master from this client.
  // Zero means no limit, it is different from qps defined in flowcontrol.RateLimiter
  // +optional
  optional int32 qps = 6;

  // Maximum burst for throttle.
  // Zero means no limit
  // This value must be bigger than QPS if QPS is not 0
  // +optional
  optional int32 burst = 7;

  // QPSDivisor divites QPS to a new float32 qps value because we can not use float32
  // type in API Struct according to API convention.
  // It allows you to set a more precise qps, like 0.01 (qps:1, qpsDivisor:100)
  // +optional
  optional int32 qpsDivisor = 8;

  // ServerName is passed to the server for SNI and is used in the client to check server
  // ceritificates against. If ServerName is empty, the upstreamcluster name used to contact the
  // server is used.
  optional string serverName = 9;
}

message DispatchPolicy {
  // Specifies a load balancing method for a server group
  optional string strategy = 1;

  // UpstreamSubset indacates to the list of upstream endpoints. An empty set
  // means use all upstreams
  // +optional
  repeated string upstreamSubset = 2;

  // Rules holds all the DispatchPolicyRules for this policy
  // Gateway matches rules according to the list order, the previous rules
  // take higher precedence
  // +optional
  repeated DispatchPolicyRule rules = 3;

  // FlowControlSchemaName indicates to which flow control schema in spec.FlowControl will
  // take effect on this prolicy
  // If not set, there is no limit
  // +optional
  optional string flowControlSchemaName = 4;

  // dispatch policy level access log mode
  // - if set to off, all access logs of requests matching this policy will be disabled.
  // - if set to on, access logs will be enabled when spec.Logging.Mode is "on" or ""
  // - if set to unset, the logging is controlled by spec.Logging.Mode
  // +optional
  optional string logMode = 5;
}

// DispatchPolicyRule holds information that describes a policy rule
message DispatchPolicyRule {
  // Verbs is a list of Verbs that apply to ALL the ResourceKinds and AttributeRestrictions contained in this rule.
  // - "*" represents all Verbs.
  // - An empty set mains that nothing is allowed.
  // - use '-' prefix to invert verbs matching, e.g. "-get" means match all verbs except "get"
  repeated string verbs = 1;

  // APIGroups is the name of the APIGroup that contains the resources.  If multiple API groups are specified, any action requested against one of
  // the enumerated resources in any API group will be allowed.
  // - "*" represents all APIGroups.
  // - An empty set mains that nothing is allowed.
  // - use '-' prefix to invert apiGroups matching, e.g. "-apps" means match all apiGroups except "apps"
  repeated string apiGroups = 2;

  // Resources is a list of resources this rule applies to.
  // - "*" represents all Resources.
  // - An empty set mains that nothing is allowed.
  // - use "{resource}/{subresource}" to match one resource's subresource
  // - use "*/{subresource}" to match all resources' subresource, but "{resource}/*" is not allowed.
  // - use '-' prefix to invert resources matching, e.g. "-deployments" means match all resources except "deployments".
  repeated string resources = 3;

  // ResourceNames is an optional white list of names that the rule applies to.
  // - "*" represents all ResourceNames.
  // - An empty set means that everything is allowed.
  // - use '-' prefix to invert resourceNames matching, e.g. "-nginx" means match all resourceNames except "nginx"
  // +optional
  repeated string resourceNames = 4;

  // Users is a list of users this rule applies to.
  // - "*" represents all Users.
  // - if ServiceAccounts is empty, an empty set means that everything is allowed, otherwise it means nothing is allowed.
  // use '-' prefix to invert users matching, e.g. "-admin" means match all users except "admin"
  // +optional
  repeated string users = 5;

  // ServiceAccounts is a list of serviceAccont users this rule applies to. It can be covered if Users matches all.
  // - ServiceAccounts can not use invert matching
  // - if Users is empty, an empty set mains that nothing is allowed, otherwise it means nothing is allowed.
  // - serviceAccount name and namespace must be set
  // +optional
  repeated ServiceAccountRef serviceAccounts = 6;

  // UserGroups is a list of users groups this rule applies to. UserGroupAll represents all user groups.
  // - "*" represents all UserGroups.
  // - An empty set means that everything is allowed.
  // - use '-' prefix to invert userGroups matching, e.g. "-system:controllers" means match all userGroups except "system:controllers"
  // +optional
  repeated string userGroups = 7;

  // NonResourceURLs is a set of partial urls that a user should have access to.  *s are allowed, but only as the full, final step in the path
  // Since non-resource URLs are not namespaced, this field is only applicable for ClusterRoles referenced from a ClusterRoleBinding.
  // Rules can either apply to API resources (such as "pods"or "secrets") or non-resource URL paths (such as "/api"),  but not both.
  // - "*" represents all NonResourceURLs.
  // - An empty set mains that nothing is allowed.
  // - NonResourceURLs can not use invert matching
  repeated string nonResourceURLs = 8;
}

message EndpointInfo {
  optional string Leader = 1;

  optional int32 shardID = 2;

  optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastHeartbeat = 3;
}

// Represents no limit flow control.
message ExemptFlowControlSchema {
}

message FlowControl {
  repeated FlowControlSchema flowControlSchemas = 1;
}

message FlowControlSchema {
  // Schema name
  optional string name = 1;

  // Schema config
  optional FlowControlSchemaConfiguration flowControlSchemaConfiguration = 2;

  optional string strategy = 3;
}

// Represents the configuration of flow control schema
// Only one of its members may be specified
message FlowControlSchemaConfiguration {
  // Exempt represents no limits on a flow.
  // +optianal
  optional ExemptFlowControlSchema exempt = 1;

  // MaxRequestsInflight represents a maximum concurrent number of requests
  // in flight at a given time.
  // +optianal
  optional MaxRequestsInflightFlowControlSchema maxRequestsInflight = 2;

  // TokenBucket represents a token bucket approach. The rate limiter allows bursts
  // of up to 'burst' to exceed the QPS, while still maintaining a smoothed qps
  // rate of 'qps'.
  // +optianal
  optional TokenBucketFlowControlSchema tokenBucket = 3;

  // GlobalMaxRequestsInflight represents a maximum global concurrent number of requests
  // in flight at a given time.
  // +optianal
  optional MaxRequestsInflightFlowControlSchema globalMaxRequestsInflight = 4;

  // GlobalTokenBucket represents a global token bucket approach. The rate limiter allows bursts
  // of up to 'burst' to exceed the QPS, while still maintaining a smoothed qps
  // rate of 'qps'.
  // +optianal
  optional TokenBucketFlowControlSchema globalTokenBucket = 5;
}

// Represents token bucket rate limit approach.
message LimitItemDetail {
  // MaxRequestsInflight represents a maximum concurrent number of requests
  // in flight at a given time.
  // +optianal
  optional MaxRequestsInflightFlowControlSchema maxRequestsInflight = 1;

  // TokenBucket represents a token bucket approach. The rate limiter allows bursts
  // of up to 'burst' to exceed the QPS, while still maintaining a smoothed qps
  // rate of 'qps'.
  // +optianal
  optional TokenBucketFlowControlSchema tokenBucket = 2;
}

message LoggingConfig {
  // upstream cluster level log mode
  // - if set to off, all access logs of requests to this cluster will be disabled.
  // - if set to on, access logs of requests to this cluster will be enabled. But it
  //   can be override by dispatchPolicy.LogMode
  // - if unset, the logging is controlled by dispatchPolicy.LogMode
  optional string mode = 1;
}

// Represents a maximum concurrent number of requests in flight at a given time.
message MaxRequestsInflightFlowControlSchema {
  // maximum concurrent number of requests
  optional int32 max = 1;
}

// RateLimitAcquire represents a acquire request for a resource.
message RateLimitAcquire {
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional RateLimitAcquireSpec spec = 2;

  optional RateLimitAcquireStatus status = 3;
}

message RateLimitAcquireRequest {
  optional string flowControl = 1;

  // Limit tokens required of this flowcontrol
  optional int32 tokens = 2;
}

message RateLimitAcquireResult {
  optional string flowControl = 1;

  optional bool accept = 2;

  optional int32 limit = 3;

  optional string error = 4;
}

// RateLimitAcquireSpec defines the request body for acquire
message RateLimitAcquireSpec {
  // Rate limit client instance identity
  optional string instance = 1;

  // Limit tokens requested
  repeated RateLimitAcquireRequest requests = 2;

  // Request id
  optional int64 requestID = 3;
}

// RateLimitAcquireStatus defines the response body for acquire
message RateLimitAcquireStatus {
  repeated RateLimitAcquireResult results = 1;
}

// RateLimitCondition is the Schema for the upstreamclusters API
message RateLimitCondition {
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional RateLimitSpec spec = 2;

  optional RateLimitStatus status = 3;
}

// RateLimitConditionList contains a list of RateLimitCondition
message RateLimitConditionList {
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated RateLimitCondition items = 2;
}

message RateLimitItemConfiguration {
  // Schema name
  optional string name = 1;

  // Expect limit config detail
  optional LimitItemDetail expect = 2;

  optional string strategy = 3;
}

message RateLimitItemStatus {
  // Schema name
  optional string name = 1;

  // Current limit status detail
  optional LimitItemDetail current = 2;

  // percent of ( actual requests / limit threshold )
  optional int32 requestLevel = 3;
}

message RateLimitServerInfo {
  optional string server = 1;

  optional string id = 2;

  optional string version = 3;

  optional int32 shardCount = 4;

  repeated int32 managedShards = 5;

  repeated EndpointInfo endpoints = 6;
}

// RateLimitSpec defines the expect rate limit state of UpstreamCluster
message RateLimitSpec {
  // All rate limit requests must specify a upstreamCluster.
  optional string upstreamCluster = 1;

  // Rate limit client instance identity
  optional string instance = 2;

  // Client flow control settings, e.g. qps and burst
  repeated RateLimitItemConfiguration limitItemConfigurations = 3;
}

// RateLimitStatus defines the rate limit state of UpstreamCluster
message RateLimitStatus {
  // Client flow control settings, e.g. qps and burst
  repeated RateLimitItemStatus limitItemStatuses = 1;
}

message SecretReferecence {
  // `namespace` is the namespace of the secret.
  // Required
  optional string namespace = 1;

  // `name` is the name of the secret.
  // Required
  optional string name = 2;
}

message SecureServing {
  // KeyData contains PEM-encoded data from a client key file for TLS.
  // The serialized form of data is a base64 encoded string
  optional bytes keyData = 1;

  // CertData contains PEM-encoded data from a client cert file for TLS.
  // The serialized form of data is a base64 encoded string
  optional bytes certData = 2;

  // ClientCAData contains PEM-encoded data from a ca file for TLS.
  // The serialized form of data is a base64 encoded string
  optional bytes clientCAData = 3;

  // ServerNames are used to route requests with different hostnames for the same upstream cluster.
  repeated string serverNames = 4;
}

message ServiceAccountRef {
  optional string name = 1;

  optional string namespace = 2;
}

// Represents token bucket rate limit approach.
message TokenBucketFlowControlSchema {
  // QPS indicates the maximum QPS to the master from this client.
  // It can not be zero
  optional int32 qps = 1;

  // Maximum burst for throttle.
  // This value must be bigger than QPS if QPS is not 0
  // +optional
  optional int32 burst = 2;
}

// UpstreamCluster is the Schema for the upstreamclusters API
message UpstreamCluster {
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional UpstreamClusterSpec spec = 2;

  optional UpstreamClusterStatus status = 3;
}

// UpstreamClusterList contains a list of UpstreamCluster
message UpstreamClusterList {
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated UpstreamCluster items = 2;
}

message UpstreamClusterServer {
  // Endpoint is the backend api server address, like https://apiserver.com:6443
  optional string endpoint = 1;

  // Disabled marks the server as permanently unavailable.
  // +optional
  optional bool disabled = 2;
}

// UpstreamClusterSpec defines the desired state of UpstreamCluster
message UpstreamClusterSpec {
  // Servers contains a group of upstream api servers
  repeated UpstreamClusterServer servers = 1;

  // Client connection config for upstream api servers
  optional ClientConfig clientConfig = 2;

  // Secures serving config for upstream cluster
  optional SecureServing secureServing = 3;

  // Client flow control settings, e.g. qps and burst
  optional FlowControl flowControl = 4;

  // DispatchPolicies describes how to dispatch requests to upsteams.
  // Only one dispatch policy will be matched
  // The router will follow the order of DispatchPolicies, that means
  // the previous policy has higher priority
  repeated DispatchPolicy dispatchPolicies = 5;

  // Logging config for upstream cluster
  //
  // There are three places to control the log switch
  // 1. flag --enable-proxy-access-log: If it is false, all proxy access log
  //    will be disabled.
  // 2. log mode in upstream, it allows you control cluster level log switch. If it
  //    is off, all access logs of requests to this cluster will be disabled.
  // 3. log mode in dispatchPolicy, it allows you control policy level log switch.
  //    If it is off, all access logs of requests matching this policy will be disabled.
  optional LoggingConfig logging = 6;
}

// UpstreamClusterStatus defines the observed state of UpstreamCluster
message UpstreamClusterStatus {
}

