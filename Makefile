
# =====================================================================
#   This file was autogenerated. Do not edit it manually!
#   save all your custom variables and targets in Makefile.expansion!
# =====================================================================
#
# Old-skool build tools.
#
# Commonly used targets (see each target for more information):
#   all: Build code.
#   test: Run tests.
#   clean: Clean up.
# 

# It's necessary to set this because some environments don't link sh -> bash.
SHELL := /bin/bash

# Default target
.DEFAULT_GOAL := all

# We don't need make's built-in rules.
MAKEFLAGS += --no-builtin-rules
.SUFFIXES:

# Constants used throughout.
.EXPORT_ALL_VARIABLES:
# This controls the verbosity of the build.  Higher numbers mean more output.
VERBOSE ?= 1

# enable go module
GO111MODULE := on

# Get the currently used golang install path (in GOPATH/bin, unless GOBIN is set)
ifeq (,$(shell go env GOBIN))
GOBIN=$(shell go env GOPATH)/bin
else
GOBIN=$(shell go env GOBIN)
endif

MYBUILD="hack/make-rules/build.sh"

define command_exists
	@$(shell command -v $(1) >/dev/null 2>&1)
endef

# user defined Makefile to expands targets
-include Makefile.expansion

.PHONY: make-rules
make-rules:
ifeq (, $(shell command -v make-rules))
	@cd $(shell mktemp -d) && go get -v github.com/zoumo/make-rules/cmd/make-rules@v0.2.0
MYMAKE=$(GOBIN)/make-rules
else
MYMAKE=$(shell command -v make-rules)
endif

define ALL_HELP_INFO
# Build code.
# make all == make build
#
# Args:
#   WHAT: Directory names to build.  If any of these directories has a 'main'
#     package, the build will produce executable files under bin/.
#     If not specified, "everything" will be built.
#   GOFLAGS: Extra flags to pass to 'go' when building.
#   GOLDFLAGS: Extra linking flags passed to 'go' when building.
#   GOGCFLAGS: Additional go compile flags passed to 'go' when building.
#
# Example:
#   make
#   make all or make build
#   make build WHAT=cmd/server GOFLAGS=-v
#   make all GOGCFLAGS="-N -l"
#     Note: Use the -N -l options to disable compiler optimizations an inlining.
#           Using these build options allows you to subsequently use source
#           debugging tools like delve.
endef
.PHONY: all build
ifeq ($(HELP),y)
all build:
	@echo "$$ALL_HELP_INFO"
else
all build: make-rules
	@$(MYBUILD) $(WHAT)
endif 

define GO_BUILD_HELP_INFO
# Build code.
#
# Args:
#   GOFLAGS: Extra flags to pass to 'go' when building.
#   GOLDFLAGS: Extra linking flags passed to 'go' when building.
#   GOGCFLAGS: Additional go compile flags passed to 'go' when building.
#
# Example:
#   make $(1)
#   make $(1) GOFLAGS=-v
#   make $(1) GOGCFLAGS="-N -l"
#     Note: Use the -N -l options to disable compiler optimizations an inlining.
#           Using these build options allows you to subsequently use source
#           debugging tools like delve.
endef
.PHONY: $(GO_BUILD_TARGETS)
ifeq ($(HELP),y)
$(GO_BUILD_TARGETS):
	$(call GO_BUILD_HELP_INFO, $@)
else
$(GO_BUILD_TARGETS): make-rules
	@$(MYBUILD) $@
endif 

define UNITTEST_HELP_INFO
# Run uniitest 
#
# Args:
#   GOFLAGS: Extra flags to pass to 'go' when building.
#   GOLDFLAGS: Extra linking flags passed to 'go' when building.
#   GOGCFLAGS: Additional go compile flags passed to 'go' when building.
#
# Example:
#   make
#   make unittest
#   make unittest GOFLAGS="-v -x"
#   make unittest GOGCFLAGS="-N -l"
#     Note: Use the -N -l options to disable compiler optimizations an inlining.
#           Using these build options allows you to subsequently use source
#           debugging tools like delve.
endef
.PHONY: unittest
ifeq ($(HELP),y)
unittest:
	@echo "$$UNITTEST_HELP_INFO"
else
unittest: make-rules
	@$(MYMAKE) go unittest
endif 

define BUILD_LOCAL_HELP_INFO
# Build code on local.
#
# Args:
#   WHAT: Directory names to build.  If any of these directories has a 'main'
#     package, the build will produce executable files under bin/.
#     If not specified, "everything" will be built.
#   GOFLAGS: Extra flags to pass to 'go' when building.
#   GOLDFLAGS: Extra linking flags passed to 'go' when building.
#   GOGCFLAGS: Additional go compile flags passed to 'go' when building.
#
# Example:
#   make
#   make build-local
#   make build-local WHAT=cmd/server GOFLAGS=-v
#   make build-local GOGCFLAGS="-N -l"
#     Note: Use the -N -l options to disable compiler optimizations an inlining.
#           Using these build options allows you to subsequently use source
#           debugging tools like delve.
endef
.PHONY: build-local
ifeq ($(HELP),y)
build-local:
	@echo "$$BUILD_LOCAL_HELP_INFO"
else
build-local: make-rules
	@$(MYBUILD) $(WHAT)
endif 

define BUILD_IN_CONTAINER_HELP_INFO
# Build code in container.
#
# Args:
#   WHAT: Directory names to build.  If any of these directories has a 'main'
#     package, the build will produce executable files under bin/.
#     If not specified, "everything" will be built.
#   GOFLAGS: Extra flags to pass to 'go' when building.
#   GOLDFLAGS: Extra linking flags passed to 'go' when building.
#   GOGCFLAGS: Additional go compile flags passed to 'go' when building.
#
# Example:
#   make
#   make build-in-container
#   make build-in-container WHAT=cmd/server GOFLAGS=-v
#   make build-in-container GOGCFLAGS="-N -l"
#     Note: Use the -N -l options to disable compiler optimizations an inlining.
#           Using these build options allows you to subsequently use source
#           debugging tools like delve.
endef
.PHONY: build-in-container
ifeq ($(HELP),y)
build-in-container:
	@echo "$$BUILD_LINUX_HELP_INFO"
else
build-in-container: make-rules
	@$(MYBUILD) $(WHAT)
endif 

define CONTAINER_HELP_INFO
# Build container image.
#
# Args:
#   WHAT: Directories containing Dockerfile.
#
# Example:
#   make container
#   make container WHAT=build/server
endef
.PHONY: container 
ifeq ($(HELP),y)
container:
	@echo "$$CONTAINER_HELP_INFO"
else
container: make-rules
	@$(MYMAKE) container build --version="$(VERSION)" --v="$(VERBOSE)" $(WHAT)
endif 

define DOCKER_BUILD_HELP_INFO 
 # Build container image.
#
# Example:
#   make $(1)  
endef
.PHONY: $(DOCKER_BUILD_TARGETS)
ifeq ($(HELP),y)
$(DOCKER_BUILD_TARGETS):
	$(call DOCKER_BUILD_HELP_INFO, $@)
else
$(DOCKER_BUILD_TARGETS): make-rules
	@$(MYMAKE) container build --version="$(VERSION)" --v="$(VERBOSE)" $@
endif 

define PUSH_HELP_INFO
# Push container image.
# You should run make container before push
#
# Args:
#   WHAT: Directory names containing Dockerfile.
#
# Example:
#   make push
#   make push WHAT=build/server
endef
.PHONY: push 
ifeq ($(HELP),y)
push:
	@echo "$$PUSH_HELP_INFO"
else
push: make-rules
	@$(MYMAKE) container push --version="$(VERSION)" --v="$(VERBOSE)" $(WHAT)
endif 


define CLEAN_HELP_INFO
# Remove all output binaries.
#
# Example:
#   make clean
#
endef
.PHONY: clean
ifeq ($(HELP),y)
clean:
	@echo "$$CLEAN_HELP_INFO"
else
clean:
	@rm -rf bin/
	@rm -rf output/
endif

define FORMAT_HELP_INFO
# Format go file
#
# Example:
#   make format
#
endef
.PHONY: format 
ifeq ($(HELP),y)
format:
	@echo "$$FORMAT_HELP_INFO"
else
format:
	@$(MYMAKE) go format
endif


define UPDATE_GOMOD_HELP_INFO
# Update go.mod
#
# Example:
#   make update-gomod
#
endef
.PHONY: update-gomod
ifeq ($(HELP),y)
update-gomod:
	@echo "$$UPDATE_GOMOD_HELP_INFO"
else
update-gomod:
	@$(MYMAKE) go mod update
endif

.PHONY: debug-makefile
debug-makefile:
	env

